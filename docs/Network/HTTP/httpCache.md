# HTTP Cache 缓存

前面在浏览器有一章节对web缓存作了介绍。所以我们知道http缓存实际上指的是浏览器`from disk cache`的那部分内容，主要针对页面资源的缓存。

## web 缓存类型

从全栈前后端的角度，web缓存分为：

- 客户端：浏览器缓存
    - 页面资源缓存：from ServiceWorker / from memory cache / from disk cache (http cache)
    - 本地数据缓存
- 服务端： 代理服务器缓存 和 CDN 缓存
- 数据库数据缓存

## http cache

所以从上面的分类看，http cache只属于其中的一部分内容。本节主要讲解此部分内容，并且以现代浏览器的缓存方式讲解，即`Cache-Control`控制，关于web 缓存更全的内容可以转到浏览器章节。

整个http cache 缓存知识，我们可以从下面的这三个维度来记忆：

- 缓存存储策略
- 缓存过期策略
- 缓存对比策略

### 缓存目标

HTTP 缓存只能存储 GET 响应的资源，对于其他请求类型的响应则无能为力。一般只有GET请求返回的资源才会被缓存


### 缓存存储策略

缓存存储策略决定了首次请求到的资源是否需要进行缓存，以及再次请求资源时是向服务器请求还是从缓存中获取。

> 在HTTP1.1中`Cache-Control`头字段应用之前，是GET请求到的资源都默认被缓存的，所以那时没有缓存存储策略，只需要关注缓存多久的设置，即`Eexpires`头字段的设置。

**首次请求到的资源是否需要缓存**

主要看依据响应头`Cache-Control`值。

- `Cache-Control: no-store`时，该资源是不被缓存的，其它值都会被缓存。
- `Cache-Control: public`时，共享缓存，即任何节点都可以缓存当前资源，包括代理服务器，网关服务器，终端浏览器。（因为客户端与服务器端往往还存在很多中间服务器）
`Cache-Control: prviate`时，私有缓存，即中间节点不可以缓存当前资源，只允许终端浏览器进行缓存
`Cache-Control: no-cache`时，强制确认缓存，即可以被缓存，但是再次使用缓存资源前应该先向服务器请求一次进行缓存对比策略，即服务器返回304时才可使用缓存。

**再次请求资源是否从缓存获取**

主要依据响应头`Vary`以及`Cache-Control:no-cache`的设置。

- 当`Vary`值设置需要比对的响应头值不一样时，则不使用缓存，直接从服务器获取
- 当没有设置`Vary`头，或者`Vary`指定的头字段值一致时，才判断`Cache-Control`值，如果是`no-cache`则向服务器请求验证是否可以使用缓存，如果值不是`no-cache`则进行下一个缓存过期策略的验证。

### 缓存过期策略

缓存过期策略主要依据`Cache-Control:max-age=<seconds>`。表示资源能够被缓存（保持新鲜）的最大时间间隔，在此时间内即为新鲜，可以使用，若超过间隔时长，则过期不新鲜了，需要从新向服务器请求资源。

> 在HTTP1.0时，缓存时间是使用`Expires=<time>`，表示缓存的到期时间。但因为客户端时间经常无法保证与服务器一致，所以存在问题。但日常为了保持向下兼容会同时设置该值。当同时存在时，优先级小于max-age的值。

### 缓存对比策略

缓存对比策略也叫缓存协商策略，即每次请求服务器，由服务器执行缓存对比策略，决定返回304继承使用缓存，还是返回200全新资源。

首次返回资源时，会有响应头字段`Etag` 或者旧版本的`Last-Modified`，然后当需要执行缓存对比策略时，再次向服务器请求时会带上请求头`If-None-Match`(值是首次返回的`Etag`字段值)，或者旧版本的`If-Modified-Since`(值是首次返回的`Last-Modified`字段值)。

> 旧版本的`Last-Modified`字段值是一个时间，即文件最后一次修改时间，以秒为单位。所以存在两种情况，当前服务器资源文件在1秒内有修改保存时就不准，另外文件修改了又撤消改回去，实际内容没变更，但最后修改时间还是会被更新，此时也不准。所以最新版本采用`Etag`是完全由一定算法计算文件内容是否一致，所以更为精准。（一般用MD5对文件进行计算，结果赋值`Etag`)

### 补充：带Vary头的缓存

HTTP响应头`Vary`的值是指定一个需要对比的其它头字段，可以一个或多个。当再次请求时，`Vary`指定的头字段，在首次请求被缓存的资源中对应请求头和再次请求时对应的请求头字段值完全一致，才进行下一步缓存策略。如果不同，则不使用缓存，直接向服务器发起请求。

[具体示例见MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)

![HTTPVary.png](../imgs/HTTPVary.png)

使用场景：

当使用响应头`Vary: User-Agent`时，使用缓存前需要通过`User-Agent`判断是否使用缓存的页面。此时就可以区分移动端和桌面端的展示内容，因为移动版和桌面的客户端的请求头中的User-Agent不同， 缓存服务器不会错误地把移动端的内容输出到桌面端到用户。


参考链接：

[MDN HTTP 缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ)<br>
[HTTP缓存控制小结](https://imweb.io/topic/5795dcb6fb312541492eda8c)