# V8 内存管理机制

[[toc]]
## 数据存取机制 栈和堆

数据存取机制：堆空间（Heap）和栈空间（Stack）

待补充...


## 垃圾回收机制 GC(Garbage Collection)

通常情况下，编程语言对内存的垃圾数据回收分为手动和自动两种策略。
- 手动回收策略：何时分配内存、何时销毁内存都是由代码控制的，典型的语言如 C、Rust 等。
- 自动回收策略：产生的垃圾数据是由垃圾回收器来释放的，并不需要程序员通过代码来释放，典型语言如 Javascript、Python 等。

在 JavaScript 语言中，垃圾回收的对象有两个：
- 调用栈中的数据回收：JavaScript 引擎 V8 会通过向下移动 ESP(记录当前执行状态的指针) 来销毁该函数保存在栈中的执行上下文。
- 堆中的数据回收：JavaScript 引擎 V8 会把堆分为新生代和老生代两个区域，新生代中用 `Scavenge` 算法来处理，老生代中用 `Mark` 算法来处理。

### 新生代中垃圾回收

新生代中用 `Scavenge` 算法来处理，把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾回收操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，这个复制过程，也相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去.

为了执行效率，一般新生区的空间会被设置得比较小，也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略,也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 老生代中的垃圾回收
老生代中用标记Mark`算法来处理，分为三步：
- **标记阶段**：标记阶段就是从一组根元素开始，递归遍历这组根元素(遍历调用栈)，在这个遍历过程中进行标记，能到达的元素称为活动对象,没有到达的元素就可以判断为垃圾数据。
- **清除阶段**：标记完成后就进行清除过程，使用标记清除（Mark-Sweep）的算法来处理。它和新生代的垃圾清除过程完全不同，这个的清除过程是就是直接删除已标记的数据。
- **整理阶段**：删除数据后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了标记整理`Mark-Compact`算法，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，从而让存活对象占用连续的内存块。

### 执行垃圾回收的时机

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿**。

在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在垃圾回收过程中无法执行，这将会造成页面的卡顿现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记（Incremental Marking）**算法.

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。

## 内存泄漏

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

### 内存泄漏的原因

1. 缓存：有时候为了方便数据的快捷复用，我们会使用缓存,但是缓存必须有一个大小上限才有用。高内存消耗将会导致缓存突破上限，因为缓存内容无法被回收。
2. 全局变量：除了代码中正常设置了全局变量外，有时因为代码不规范意外导致的全局变量，比如 JS 中使用未声明的变量等。
3. 计时器中引用没有清除。比如下面这段代码，定义了一个计时器，每隔1s把一些数据写到Node节点里面。但是当这个Node节点被删除后，这里的逻辑其实都不需要了，但是因为没有清除定时器，导致了计时器里面的回调函数无法被回收，继而导致 someData里的数据也无法被回收，因为被定时器里的回调函数引用着。
```js
var someData = getData();
setInterval(
  function() {
    var node = document.getElementById('Node');
    if(node) {
      node.innerHTML = JSON.stringify(someData));
    }
}, 1000);
```
4. 事件监听未移除，原因同上面计时器类似，事件监听处理函数无法被回收，函数内引用的变量也无法被回收。
5. 闭包
```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;

  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () { console.log('someMessage') }
  };

  return function unused () {
    if (originalThing) console.log("hi");
  };
};
setInterval(replaceThing, 1000);
```
每次调用 replaceThing ，theThing 会创建一个大数组，函数 unused 是一个引用 originalThing(theThing) 的闭包，闭包的链表一旦创建，k只要 replaceThing 还被引用着，那每一个闭包作用域携带一个指向大数组的间接的引用，造成严重的内存泄漏。因此，当这段代码反复运行，就会看到内存占用不断上升，垃圾回收器（GC）并无法降低内存占用。

### 内存泄漏的识别方法

1. 使用 Chrome 任务管理器实时监视内存使用，可以看到内存占用空间和JavaScript使用的内存
2. 利用chrome的(DevTools)中的 Performance 面板录制页面中JS内存使用情况、节点数量、监听器数量。
3. 使用 Memory 面板查看已分离 DOM 树的内存泄漏
4. 利用 Profiler 面板按函数调查内存分配


### 避免内存泄漏
1. 少用全局变量，避免意外产生全局变量
2. 使用闭包要及时注意，有Dom元素的引用要及时清理。
3. 计时器要记得销毁。
4. 事件监听要记得移除
5. 为了避免疏忽导致的遗忘，我们可以使用 WeakSet 和 WeakMap 结构，它们对于值的引用都是不计入垃圾回收机制的，表示这是弱引用。

## 参考链接
- [Chrome 浏览器垃圾回收机制与内存泄漏分析](https://cloud.tencent.com/developer/article/1557608)