# 页面渲染流程

从一道经典的面试题展开：

在浏览器里，从输入 URL 到页面展示，这中间发生了什么？

![browser_process](./img/browser_process.png)


1. 触发当前页的卸载事件和收集需要释放内存
1. <b>合成URL：</b>浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的URL；如果用户输入的内容符合URL规则，浏览器就会根据URL协议，在这段内容上加上协议合成合法的URL。此时浏览器导航栏显示loading状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得。涉及[URI URL URN概念解释](/Network/HTTP/URI_MIME.html)
1. <b>传送URL：</b>浏览器通过进程间通信（IPC）将URL请求发送给网络进程
1. <b>查找缓存：</b>网络进程获取到URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接200返回；否则，进入网络请求过程。涉及[web缓存知识](/Browser/04_web_cache.html#什么是web缓存)
1. <b>DNS寻址：</b>网络进程请求DNS返回域名对应的IP和端口号，如果之前DNS数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的IP和端口号，如果没有端口号，http默认80，https默认443。如果是https请求，还需要建立TLS连接。
1. <b>TCP连接排队：</b>Chrome 有个机制，同一个域名同时最多只能建立 6 个TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立TCP连接。
1. <b>TCP建立连接：</b>TCP三次握手建立连接
1. <b>HTTP请求构建：</b>构建http请求，并且加上TCP头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输。涉及[HTTP总结](/Network/HTTP/introduce.html#http-%E6%A6%82%E8%BF%B0)
1. 网络层在数据包上加上IP头部——包括源IP地址和目的IP地址，继续向下传输到底层
1. 底层通过物理网络传输给目的服务器主机
1. 目的服务器主机网络层接收到数据包，解析出IP头部，识别出数据部分，将解开的数据包向上传输到传输层
1. 目的服务器主机传输层获取到数据包，解析出TCP头部，识别端口，将解开的数据包向上传输到应用层
1. 应用层HTTP解析请求头和请求体，如果需要重定向，HTTP直接返回HTTP响应数据的状态statusCode=301或者302，同时在请求头的Location字段中附上重定向地址，浏览器会根据statusCode和Location进行重定向操作；如果不是重定向，首先服务器还会根据请求头中是否有`If-None-Match` 或者`If-Modified-Since`字段的值来校验请求的资源是否被更新，如果没有更新，就返回304状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200的状态码，并且如果想要浏览器缓存数据的话，就设置相应的响应头字段：`Cache-Control 或 Expires`。涉及[HTTP Cache 缓存策略](/Network/HTTP/httpCache.html#http-cache)
1. 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程
1. 数据传输完成，**TCP四次挥手断开连接**。如果，浏览器或者服务器在HTTP头部加上如下信息`Connection:Keep-Alive`，TCP就一直保持连接。保持TCP连接可以省下下次需要建立连接的时间，提升资源请求加载速度，因为建立TCP连接是非常消耗资源和时间的。涉及[短连接/长连接/流水线连接](/Network/HTTP/session_connect_message.html#http-连接)
1. 网络进程将获取到的数据包进行解析，根据响应头中的`Content-type`来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是`text/html`类型，就通知浏览器进程获取到文档准备渲染。涉及[MIME 标识资源类型](/Network/HTTP/URI_MIME.html#mime-标识资源类型)
1. 浏览器进程获取到通知，根据当前页面B是否是从页面A打开的并且和页面A是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程
1. 浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程
1. 浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新web页面，此时的web页面是空白页
1. 渲染进程对文档进行页面解析和子资源加载，HTML 通过HTM 解析器转成**DOM**（二叉树类似结构的东西），CSS通过CSS解释器转成**CSSOM**，JS执行会阻塞DOM解析，CSS加载解析会阻塞JS的执行。
1. DOM和CSSOM结合，形成**render**，主要是进行样式计算（不包含HTML的具体元素和元素要画的具体位置）。
1. <b>Layout</b> 布局阶段：需要完成两件事：创建布局树和布局计算，计算出每个元素具体的宽高颜色位置。
1. 根据样式规则，进行分层**layer**
1. 根据分层信息，逐层开始绘制**Paint**
1. 绘制数据单独在合成线程进行分块**Tiles**
1. 每块进行光栅化**Rester**
1. 最后将光栅化后的像素信息提交给浏览器进行显示在屏幕中


**参考资料**

[极客专栏-浏览器工作原理与实践](https://time.geekbang.org/column/intro/216)<br>
[从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)