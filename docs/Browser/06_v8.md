# V8 引擎

- V8 引擎解析一段JS代码
    - 编译器（Compiler）
    - 解释器（Interpreter）
    - 即时编译器（JIT：Just In Time）
    - 词元（Token）
    - 抽象语法树（AST）
    - 字节码（Bytecode）
    - 机器码（machine code）


## V8 引擎

V8 是Chrome浏览器的JS引擎，像其它浏览器的JS引擎有：
- Microsoft IE/Edge浏览器的 Chakra。（在微软有一个类似Javascript的语言叫JScript）
- FireFox 浏览器的 SpiderMonkey,
- Safari 浏览器的 Javascript core
- Chrome 浏览器的 V8,

## JS引擎的作用

JavaScript 是一门高级语言，但是计算机能直接理解和执行的是机器指令码，也称机器码。

机器指令码是用于指挥计算机应该做的操作和操作数地址的一组二进制数，因为计算机最终能识别的只是0和1。

JavaScript 引擎是一种用于将我们使用JavaScript语言编写的代码转换为计算机可读的机器指令码的工具，大白话讲就是一个翻译工具。

如果没有 JavaScript 引擎，您编写的代码对计算机来说简直是一堆“胡言乱语”。不仅仅是 JavaScript ，其他所有编程语言都需要一个类似的引擎，来将这些“胡言乱语”转换成对计算机有意义的机器指令码。

## JS 引擎转换JS代码遵循的规范：ECMAScript

JS 引擎只是分析我们JS代码并将其翻译成机器码的工具。V8 是最受欢迎的 JavaScript 引擎之一，也是 Chrome 和 NodeJS 使用的引擎。它是用 C++（一种底层语言）编写的。

语言翻译要遵循语言的语法规范，ECMAScript标准就是JS的语言规范，该标准主要提供如何编写引擎和 JavaScript 所有语法规范。


## JS引擎翻译流程

> 下面涉及的基本概念在所有引擎中基本是一致的。

![js_engine.jpg](./img/v8.png)

上图就是 JS Engine 内部的工作流程。

### 概念解释：

对上图涉及的概念，简单解释如下：

#### 解释器（Interpreter）和 编译器（Compiler）

通常，将代码转换成机器可读代码的方法有两种：
- Interpreter 逐行将源代码转换为等效的机器代码，并立即执行。在每次运行时都需要通过解释器对程序代码进行动态解释和执行。例如 JavaScript
- Compiler 在一开始就读取您的整个代码，经过编译器的编译，并且编译之后会直接保留机器能读懂的机器码二进制文件。编程过程中可以对代码进行优化处理。这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。例如 C/C++、GO 等都是编译型语言。
>这些讨论的概念不仅适用于 JavaScript ，而且适用于大多数编程语言，例如 Python，Java 等。

![compiler_interpreter.png](./img/compiler_interpreter.png)

**两者优缺点：**

看下例子：
```js
// 将两个数字相加并返回总和。
function add(a, b) {
    return  a+b
}

// 循环调用了 add 函数1000次求和输出
for ( let i = 0; i < 1000; i++) {
   let ret = add(1 + 1)
   console.log(ret)
}
```
- Interpreter 接收上面的代码后，它将逐行读取并立即执行代码，直到循环结束。它的工作仅仅是实时地将代码转换为我们的计算机可以理解的机器码。代码中函数 add 被调用了1000次，虽然它的输出保持不变，但是 解释器Interpreter 还是会逐行执行，整体会显得比较慢。
- Compiler，它会先完整地读取整个程序，对我们要执行的代码进行分析，并生成电脑可以读懂的机器语言。在同样的情况下，Compiler 可以通过用2代替循环（因为 add 函数每次都是执行1 + 1）来进行一些优化。Compiler 最终给出的优化代码可以在更短的时间内执行完成。

所以两种的优缺点是：
- Interpreter 的优点是无需等待编译即可立即执行代码，但不会进行优化。这对在浏览器中运行 JS 提供了极大的便利，因为所有用户都不想浪费时间在等待代码编译这件事上。但是，当有大量的 JS 代码需要执行时会运行地比较慢。
- Compiler 虽然需要花费一些时间来编译代码，但是会生成对执行时更优的代码。

因此，考虑到编译器和解释器的优缺点，我们是不是可以同时利用两者的优点呢？

同时利用解释器和编译的器的技术称为**即时编译（JIT）**。通俗讲就是在解释器运行的同时执行编译器的工作。Java 和 Python 的虚拟机也都是基于这种技术实现的。

具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，通过分析工具收集代码信息，当它发现某一部分代码被频繁执行（称为热点代码HotSpot）就会交与编译器 TurboFan 把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。
> V8 引擎对解释器和翻译器的取名很有意思。解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码通过点火器慢慢发动，一旦代码变热，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。

#### 机器码 machine code

计算机能直接理解和执行的代码是机器指令码，也称机器码。

机器指令码是用于指挥计算机应做的操作和操作数地址的一组二进制数，因为计算机最终能识别的只是0和1。


#### 字节码 ByteCode

字节码就是介于 AST 和机器码之间的一种代码。字节码需要通过解释器将其转换为机器码后才能执行。

![bytecode.png](./img/bytecode.png)

从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。

#### AST：Abstract Syntax Tree 抽像语法树

AST：它将源代码语法结构抽象为以树状结构表示。

高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。所以无论你使用的是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。

结合下面这段代码来直观地感受下什么是 AST：

```js
var myName = "极客时间"
function foo(){ 
    return 23;
}
myName = "geektime"foo()
```
这段代码经过[javascript-ast](https://resources.jointjs.com/demos/javascript-ast)站点处理后，生成的 AST 结构如下：
![ast.png](./img/ast.png)
从图中可以看出，AST 的结构和代码的结构非常相似，其实你也可以把 AST 看成代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。

AST有着广泛的应用，比如：
- Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。
- ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。

#### Token 词元

所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。
![token](./img/token.png)

分解 token 示意图从图中可以看出，通过`var myName = “极客时间”`简单地定义了一个变量，其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。


### 执行流程

1. 分词（tokenize），又称为词法分析。

    其作用是将一行行的源码拆解成一个个 token。

2. 解析（parse），又称为语法分析。

    其作用是将上一步生成的 token 数据，根据语法规则转为 AST。（通过各种 JavaScript 关键字来识别，比如var function let const class等）。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

    在这个过程中，还会生成**执行上下文**，执行上下文主要是提供了代码执行的环境，里面有代码执行要用到的信息，比如变量信息、函数信息、this对象、指向外部引用的作用域链对象等。我们会在下一节重点讲解。

3. 生成 ByteCode
    通过解释器 Ignition 根据 AST 生成字节码，并解释执行字节码。

> 其实一开始 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，特别是运行在 512M 内存的手机上，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器，最终花了将进四年的时间，实现了现在的这套架构。

4. 执行代码

    如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。
    
    在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。


## 重要的概念

JS代码是一段一段编译并执行的。这个代码段的划定原则就是作用域的概念。

> 我们写好了一个JS代码文件，里面有函数调用，IF语句块等，这个JS文件执行时并不是一开始会把所有代码都解析成AST，然后解释编译执行的。而是先把属于全局作用域的代码作为一段代码（但不包括函数体内的代码）完成上面所讲的JS执行的整个过程，当遇到函数执行时，又把函数块内的代码当作一段代码，再走上面所讲的JS执行的全过程，如此不断通过函数调用完成JS文件的功能。

JavaScript 是一门解释型语言吗？<br>
> JavaScript 是，但不完全是一门解释型语言。Brendan Eich 最初是在 JavaScript 的早期阶段在网景浏览器中创建 JavaScript 引擎 “ SpiderMonkey” 的。该引擎只有一个解释器Interpreter 告诉浏览器该怎么执行代码。但是现在我们的引擎不仅包括了 Interpreter，还有 Compiler。我们的代码不仅可以被转换成 ByteCode，还可以被编译输出优化后的代码。因此，从技术上讲，这完全取决于引擎是如何实现的。




