# Typescript

- What: 是什么
- Why: 为什么要用，解决了什么问题
- How: 怎么用
- Deep: 深入

## What: TS 是什么？

官网的一句话：TypeScript is JavaScript with syntax for types。TypeScript是一种带有类型语法的JavaScript。

现代编程语言采用的类型系统各不相同，不同的编程语言采用不同的类型系统。根据是否需要显式声明类型和类型检查的时机不同（编译时和运行时）来区分，常见的有：[P15]
1. 不需要显式声明类型，会在运行时推导类型：JavaScript Python Ruby
1. 不需要显式声明类型，会在编译时推导和检查类型：Haskell OCaml
1. 强制要求显式注解所有类型，然后在编译时检查类型：Java C
1. 显式声明部分类型，然后在编译时会推导余下类型，并在编译时检查类型：TypeScript Scala

> 1,2 属于动态类型范畴，3,4属于静态类型范畴。
> 静态类型语言中，要求必须先声明变量类型，即在变量创建的那一刻就确定好变量的类型，然后在使用中，你只能将这一指定类型的数据赋值给变量。如果强行将其他不相干类型的数据赋值给它，就会引发错误。
> 动态类型在编码不要求类型声明，在程序运行过程中根据变量当前值确定变量类型，如果执行了该类型不支持的操作时才会引发错误。

> 强类型和弱类型之分，体现在对类型的检查严格程度上，弱类型语言对于变量类型的检查比较宽松，容忍隐式类型转换的机制。

JS 算是纯粹的动态类型语言的代表，像 Java 算纯粹的静态类型语言的代表，但 TS 并不算纯粹的静态类型语言，因为它在编译时会推导类型，所以不需要严格显式声明所有类型。也可以说TS身兼两种类型系统，可以显式注解类型，也可以自动推导多数类型。[P16]

**什么是类型？**： 一系统值以及可以对值执行的一系列操作。[P26]

比如 boolean 类型，值只有 `true / false`，可以对布尔值进行的操作包括逻辑运算 `|| && ！`等。
number 类型，值包括所有数字，以及可以对数字执行的操作（加减乘除，逻辑运算等），以及数字上可调用的方法（.toFixed toString) 等。

所以一旦某个明确了某个变量值的类型，我们就知道了可以对该变量进行什么样的操作，这就是类型。

**什么是类型系统？**：所有类型以及所有类型操作组成的一系列规则。
比如TS包含的所有类型boolean/number/string/symbol/bigint/function/array/tuple/enum/void/unknown/never/undefined/null及它们对应的操作统称为TS的类型系统。

**什么是类型检查？**：类型检查的工作往往由程序内置的类型检查器来执行，类型检查器通过该变量使用的类型以及该类型规则来判断当前对该变量执行的操作是否有效，如果执行了该类型无效操作就会报告错误。

**类型检查器**：检查代码是否符合类型安全要求的内置的特殊程序。


所以这里纠正一种说法：TS 是在 JS 的语言基础上，增加了类型系统。
JS语言本身就有自己的类型系统，如基本类型和引用类型，只不是它的类型是属于动态类型，准确点说，TS 是在 JS 的语言基础上，实现了静态类型系统，表现为在代码层面增加了类型声明的语法。所有官网的话更为精准，TS 是一种带有类型语法的 JS。

## Why: 为什么要使用 TS

为什么要使用TS，因为 TS 能把纯 JS 代码中那些在运行时的错误提前在编译时就报告出来，配合现代 IDE 的集成，能在编写代码时就提示错误。

JS 代码可以直接在浏览器使用，但是TS代码的程序需要先编译成JS代码再使用。这个增加的编译环节中就会执行类型检查。

```js
--------------         ---------------         --------------
| Typescript | ------> | TS compiler | ------> | Javascript |
--------------         ---------------         --------------
```

看下面 TS 与 JS 对比的区别，基本上也是动态类型和静态类型之间的区别了。

|    类型系统特性  |     JavaScript       |     TypeScript   |
| ---------------- | ------------------- | -----------------|
| 类型是如何绑定的 | 动态                 | 静态             |
| 是否自动转换类型 | 是（弱类型：隐式转换）| 否（多数时候）   |
| 何时检查类型     | 运行时               | 编译时           |
| 何时报告错误     | 运行时（多数时候）   | 编译时（多数时候）|

表格中【多数时候】对应的少数情况是：
1. JavaScript 在解析程序之后，运行程序之前会报告句法错误和部分缺陷，比如在同一作用域中多次使用const声明同一名变量等。如果在现代前端工程中使用babel等构建工具则会在构建时报告此类错误。
2. TypeScript 会在编译时报告句法错误和类型相关的错误，还有一些错误是 TS 在编译时无法捕获的，比如堆栈溢出、网络异常等。

## 理解 TypeScript

第一点：
TypeScript是一种带有类型语法的JavaScript。可以理解 TS 具有两层代码空间：一层是遵循 JS 语法的**值空间**，另一层是 TS 附加的类型语法的**类型空间**。所以在 TS 语言中创建一个变量，同时声明一个与变量同名的类型并不会冲突，因为两者归属不同的代码空间，在TS中这种类型声明也叫做伴生类型。

> 类型层面代码指只有类型和类型运算符的代码，其余都是值层面代码。
> 简单的判断是，如果是有效的 JS 代码，就是值层面的代码，不是有效的JS代码就是类型层面的代码。

第二点：

从上面关于 TS 类型系统的阐述：

> TypeScript 要求显式**声明**部分类型，然后在编译时会**推导**余下类型，并在编译时**检查**类型

所以理解 TypeScript 所包含的类型系统，可以从以下四个方面深入 TS
- 类型声明
- 类型推导
- 类型检查
- 类型编程

### 类型声明

类型声明，也可以叫类型注解。注解基本格式：`value: type`
```ts
let num: number = 123 // num 是一数字类型
let str: string = 'abc' // 字符串类型
let arr: boolean[] = [true, false] // 布尔值组成的数组
```

可以声明哪些类型(type)呢？TS 提供了以下几种基础类型，另外根据 TS 类型编程的特性，还衍生出了一些工具类型，实际业务中用户也可以根据TS的类型编程语法来自定义类型。

- 基类型
  - `boolean` `number` `bigint` `string` `symbol` `undefined` `null`
  - `object` `array` `function`
  - `enum` `tuple` `unknown` `any` `never` `void`
  - `字面量类型` `unique symbol`
- 内置的工具类型
  - 条件类型：`Exclude` `Extract` `NonNullable` `Parameters` `ReturnType` `ThisParameterType` `InstanceType` `ConstructorParameters`
  - 对象映射类型：`Partial` `Required` `Readonly` `Record` `Pick` `Omit`
- 自定义工具类型：[utility-types](https://github.com/piotrwitek/utility-types)

### 类型推导

1. 类型拓宽，以及如何阻止类型拓宽（显式注解、as const）
2. 类型细化（类型守卫、类型缩窄）：流式推导（流程语句、类型查询语句）、类型断言（is 运算符、as运算符、非空断言、明确赋值断言）、可辨识联合类型、类型烙印（模拟名义类型）。

> TS 在遇到以下流程语句和类型查询语句，会在语句的块级作用域内「收紧」变量的类型，也就是帮助我们块级作用域中获得更为精确的变量类型，这种类型推断的行为也称为类型守卫 (Type Guard)。

### 类型检查

检查什么？
- 可赋值性检查：类型兼容性：子类型和超类型、型变（不变、协变、逆变、双变）
- 多余属性检查：新鲜对象的字面量类型
- 全面性检查，也称为穷尽性检查，指TS会依据类型来检查代码的所有分支路径，如果有未覆盖的情形则会报错。

## 类型编程

通过TypeScript操作符，把类型当作参数进行逻辑处理，从而获得新的类型的过程称为类型编程。
我们写JS处于一个叫值空间的世界，对值进行编码，面向运行时编程。而在类型空间中，我们对类型进行编码，面向编译时编程。参考[类型体操](https://zhuanlan.zhihu.com/p/384172236)

- 类型修饰符（+ - ? readonly)
- 类型运算符
  - 定义类型： type interface infer
  - 获取类型： typeof 类型索引`[key] / [number]` keyof(获取对象所有键组成的联合类型)
  - 类型逻辑运算：| &
  - 条件类型 extends
  - 联合类型的遍历 in
- 泛型
  - 声明泛型的方式
  - 泛型约束
  - 泛型默认值
- 工具类型
  - 条件工具类型
  - 对象映射工具类型
  - 对象属性裁剪工具类型