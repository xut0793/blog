# 前端工程化

工程：前端工程化"里面的工程指软件工程。
理解：一切能提升前端开发效率，提高前端应用质量的手段和工具都是前端工程化。
目标（道）：软件工程化关注的是性能、稳定性、可用性、可维护性等方面，一切以这些为目标的工作都是"前端工程化"。
实践（术）：模块化、组件化、规范化、自动化


## 理解前端工程化

[谁能介绍下web前端工程化？](https://www.zhihu.com/question/24558375)
[一个专业的『前端工程化体系』是如何建立的？](https://www.zhihu.com/question/279540558)
[前端工程化：构建、部署、灰度](https://zhuanlan.zhihu.com/p/71562853) ----- 自动化部分内容参考
[前端工程化实践：大前端的转变之路](https://zhuanlan.zhihu.com/p/28769103) -----规范化内容参考
[前端工程](https://github.com/fouber/blog/issues/10) --- 从小到大逐步实践过程
[吃透 Vue 项目开发实践｜16个方面深入前端工程化开发技巧:上中下](https://juejin.im/post/5e0202fc6fb9a0165721e39a)

## 模块化

### JS 模块化

一. 模块规范
- CommonJS
- AMD
- CMD
- UMD
- ES module

二、模块打包工具
- Require.JS
- SeaJS
- Browserify
- Webpack
- Rollup
- parcel

三、模块加载方案
- 用浏览器的`<script type="module">`加载ES module
- import() 动态异步加载

目前Webpack模块打包最为流行。

### CSS 模块化

一、实现文件拆分、合并
- 预处理器：Sass Scss less stylus
- @import： 合并文件

问题：虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。
按道理，一个模块化的文件要实现的目的就是要隐藏内部作用域，只暴露少量接口给使用者。
而按照目前预处理器的方式，导入一个CSS模块后，仍然存在的样式有被覆盖的问题。虽然重写样式是原生CSS的一个优势，但这并不利于团队中多人协作。

二、命名规范实现弱约束

通过选择器的命名规范来避免样式覆盖。

- BEM
- OOCSS
- SMACSS
- ACSS: tomic CSS
- Bootstrap风格
- Semantic UI风格

问题：以上这些命名规范都是弱约束，靠的是团队协作上的约定。
> 与其费尽心思地告诉别人要遵守某种规则，以规避某种痛苦，倒不如从工具层面就消灭这种痛苦。

三、工具实现强制约束

从工具层面，社区又创造出Shadow DOM、CSS in JS和CSS Modules三种解决方案。

- Shadow DOM是WebComponents的标准。它能解决全局污染问题，但目前很多浏览器不兼容，对我们来说还很久远；
- CSS in JS是彻底抛弃CSS，使用JS或JSON来写样式。这种方法很激进，不能利用现有的CSS技术，而且处理伪类等问题比较困难；
- CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。

## 组件化

一、注意概念上不要混淆：组件化≠模块化。
- 模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。
- 从UI拆分下来的每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元，我们称之为组件。

二、组件化实践内容：

组件化实际上是一种按照模板(HTML)+样式(CSS)+逻辑(JS)于一体的形式对面向对象的进一步抽象。
- 封装组件
- 处理组件之间的依赖关系：比如（逻辑）继承、（样式）扩展、（模板）嵌套和包含等，这些关系都可以归为依赖。

三、组件化实现框架
- Vue
- React
- Angular

## 规范化

1. 项目结构规范

遵循分门另类，就近统一

1. 各类命名规范
- 项目文件命名
- HTML 属性、ID、类命名
- CSS 选择器命名规范
- JS 变量、常量、函数、类
- VUE 组件规范、页面路由
- HTTP 接口命名规范

2. 编码规范
- 规范标准
  - HTML:
  - CSS：[NEC](http://nec.netease.com/standard) [如何规范 CSS 的命名和书写？](https://www.zhihu.com/question/19586885)
  - JS: Standard Arbnb等
- 在书写过程中，采取ESLint和StyleLint等强制规范
- 在文件保存时，开启saveOnLint
- 在git提交时，配置git hooks实现Lint不过不能提交代码等机制

3. Git分支管理

4. Commit描述规范

5. 前后端接口规范

6. 文档规范

7. 组件规范

8. 定期CodeReview

## 自动化

> 任何简单机械的重复劳动都应该让机器去完成

[前端工程化：构建、部署、灰度](https://zhuanlan.zhihu.com/p/71562853) ----- 自动化部分内容参考

一、 理解概念

- 编译和构建概念有一些区别
- 构建产物（Artifacts）
- 部署、发布：蓝绿部署、滚动部署、金丝雀发布（灰度发布）、A/B测试


1. 快速搭建项目模板的脚手架

2. 自动化测试

3. 自动化构建

  - 概念理解：
    - 编译是指将源代码变为目标代码的过程，从源代码的语言转变为另外一种计算机语言（一般为比源代码语言更为底层的语言）。
    - 构建是指一些列的处理，包括编译。不同的语言构建会有不通的处理步骤，最终产生可在具体特性环境运行的Artifact。
    - 前端的编译主要是指将超集的语言编译为浏览器识别的基础的HTML/CSS/JS。为了更好的编程体验和更高的可维护性，会使用一些超集的语言，然后再转译为浏览器可以运行的语言。例如：
      - 对 es5/6/7 等语法的转译为对应环境支持的代码；
      - less、sass 等转译为 css；
      - typescript、coffeescript 等转译 javascript 。

  - 构建的先后过程：
    - 代码检查
    - 运行单元测试
    - 语言编译
    - 模块打包、压缩、优化
    - 版本生成

  - 构建工具
    - webpack
    - Rollup
    - Gulp
    - Grunt

4. 自动化部署

- 概念理解：
  - 部署（deploy）是指把构建后的新版本应用或服务“安装”到目标环境（开发、测试或者生产）中。这时候部署好的应用或服务应该是在目标环境中正常运行着（或者待着），但是不会有任何访问的流量。
  - 发布（release）则是把新版本应用或者服务交付给最终用户使用的过程。相当于把流量切到部署好的新版本的过程。
  - CI / CD
  - 前端项目部署一般是指文件的增量替换或全量替换。根据项目按需决定，部署和发布可以同时进行，也可以分开进行，前提是在不影响用户访问的同时，把前端的代码更新到相应的版本。

- 实践：
  - Bash 脚本
  - Docker 容器

6. 监控

7. 运维

8. 性能优化
  - 性能指标
  - 性能检测工具
  - 性能优化方向和手段

## 项目实践

依上面四个层面入手，开启一个VUE项目来进行实践。

VUE项目重点内容：

一、网络请求封装
1. 响应拦截内容
  - 自定义请求头（ x-)
  - 采用JWT或oAuth模式请求头 Authorization 
2. 响应拦截
  - 统一的错误处理方法
  - 请求错误的拦截处理
  - 业务自定义的错误码拦截处理
3. 业务接口和API接口解耦

二、路由
1. 路由拦截
  - 登录校验（token有效与否，携带redirectURL跳转登录页）
  - 权限校验（鉴权）
  - 权限菜单
2. 动态路由注册

三、数据和页面缓存的实现
四、各种环境切换的实现
五、主题切换实现
六、国际化中英文切换实现