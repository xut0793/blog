# 前端开发工作流

## 典型工作流

基本上所有软件开发的一个典型工作流，包含几个阶段：初始化、开发、构建、部署、运维。

1. 初始化
   - 环境初始化：浏览器、`IDE`配置、`nodejs`、`git`等。
   - 项目初始化：`npm init / git init`、建立目录结构或使用项目模板、统一`linter`配置等。
2. 开发：代码开发
3. 构建：构建就是创建最终的可执行文件。对web 前端开发而言，最终的构建制品就是 `HTML` 、`CSS`、`JS` 。
4. 部署：将可执行文件部署到服务器。对于前端 web 开发而言，需要部署的文件包括上述的构建制品（ `HTML` 、`CSS`、`JS` ）和静态资源文件` assets`，如图片、字体、音视频等。
5. 运维：应用运营阶段需要进行日常维护，内容包含应用性能指标的监控、错误监控、安全监控，以及其它业务运营指标监控等。

虽然总结起来的工作流阶段相同，但不同的技术领域，各个阶段内的任务却是有差别的。对于前端web开发，各个阶段中基本包含以下任务。

## 前端工作流
1. 初始化
   1. 搭建本地开发环境
   2. 搭建项目框架
   3. 套用模板代码
   4. 安装第三方依赖
2. 开发
   1. 建立本地开发服务器`dev-server`：以实现：
      1. 热更新 `HMR`：监听本地源代码的变化，自动重新构建、刷新浏览器：`live-reload / hot-reload`。
      2. 网络代理 `proxy`: 解决跨域问题
   2. 源码映射`source-map `，便于开发调试。
   3. 建立接口`mock`环境，网络代理`proxy`，便于跨域连接开发
3. 构建
   1. 代码质量：在代码被提交到仓库前需要校验代码是否符合规范，运行规范检查工具，如编码规范、源码管理规范等。
   2. 代码测试：单元测试 `unit test`、功能测试 `e2e test`。
   3. 代码编译：比如`pug => html / esnext => es5 / ts => js / less => css`等，使用编译工具：`babel`、`postcss`、`ts` 等。
   4. 代码优化：压缩和混淆代码，去除无用代码，如`js`的`tree shaking`功能，`css`的`PurifyCSS`等。
   5. 代码分割：提取第三方依赖代码、业务公共代码、提取首屏不需要执行部分的代码让其异步加载等。
   8. 模块打包：在采用模块化的项目里通过模块打包工具将分散的功能模块合并成一个`bundle`文件，或者现在最新的 bundless 模式。
4. 部署
   1. 部署到目标环境：gulp插件 gulp-sftp 自动上传、jeskin 流水线、Travis CI、gitLab-CI、github-action等。
   2. 发布上线：各种发布策略：A/B发布、蓝绿发布、灰度发布等。
5. 运维
   1. 建立监控体系，包括性能指标的监控、错误异步的监控、安全防范等内容。

## 各阶段详解
1. 搭建本地开发环境，主要指应用开发依赖的基础环境，如前端基础环境包括：代码编辑器`IDE`、浏览器、`node.js`、`git`等工具。
2. 搭建项目框架，主要指建立一个对应技术栈的最佳实践的项目目录结构。
3. 套用模板代码，基本与项目结构一起完成，主要是对一些普遍公共的代码直接引入项目中，不用重头开始重复编写，能快速开发核心的业务代码。
4. 安装第三方依赖，伴随前端模块化的发展，诞生了很多优良的功能独立的模块，能够直接运用到项目，省去了在项目中重复造轮子的浪费，便于专注于型业务逻辑的实现。
5. 运行开发服务器，web 应用运行在web服务器上才能取得最好效果，比如 AJAX 数据的交互，必须运行在服务器，所以在开发时就需要一个模拟生产环境的本地开发服务器。并且需要在代码修改保存后，自动触发相应的代码编译、质量和规范检查，快速将运行结果展现在浏览器里，验证功能结果，加快代码调试和开发效率。
6. 规范检查和代码质量，在开发阶段就将错误暴露，才能在生产环境中避免问题，如 `ESLint / stylelint / Pretter` 等。
7. 代码编译，编译是指将源代码变为目标代码的过程，从源代码的语言转变为另外一种计算机语言（一般为比源代码语言更为底层的语言）。前端的编译主要是指将超集的语言编译为浏览器识别的基础的`HTML/CSS/JS`。开发时为了更好的编程体验和更高的可维护性，会使用一些超集的语言，然后再转译为浏览器可以运行的语言。例如：
   - 利用`pug`书写`HTML`需要编译成正常的`HTML`；
   - 利用 `babel` 对 `es6/7 `等语法的转译为对应环境支持版本的语法；
   - 利用 `less / postcss` 等转译为正常的`css`；
   -  `typescript`也需要转译 `ecmascript` 。
8. 模块打包，模块化有利于开发时功能逻辑的解耦和代码组织，但在生产中，web 应用中每一个文件都会导致浏览器建立一个新的HTTP连接去下载它，而每一个HTTP连接都是消耗时间和机器性能的，所以最好将模块化开发中多模块文件尽可能打包捆绑成一个或几个 `bundle` 文件，减少对服务器的请求数。
9. 代码调优，每一个HTTP连接进行传输的字节都要消耗流量，所以需要用压缩和混淆代码的方式来优化代码体积，比如移除空格、空行、注释、缩短函数和变量名、删除多余的调试代码和没有应用到冗余代码等。对于图片，图片文件本身存储了很多元信息，这些信息不但无法被浏览器解释，反而会白白增大图片体积浪费网络带宽，所以需要利用工具删除一些没必要的元信息，使用更好的压缩算法优化图片大小。
10. 部署（deploy）是指把构建后新版本的应用或服务安装到目标环境（开发、测试或者生产）中。这时候部署好的应用或服务应该是在目标环境中正常运行着（或者待着），**但是不会有任何访问的流量**。
11. 发布（release）则是把新版本应用或者服务交付给最终用户使用的过程。相当于**把流量切到部署好的新版本的过程**。根据项目需要决定，部署和发布可以同时进行，也可以分开进行，前提是在不影响用户访问的同时，把前端的代码更新到相应的版本。所以会对不同的应用场景采用不同的发布策略。常见的发布策略有蓝绿发布、金丝雀发布（灰度发布）、滚动发布。[A/B测试、金丝雀发布（灰度发布）、蓝绿部署、滚动部署](https://zhuanlan.zhihu.com/p/205173464)

>延伸概念：
>CI，Continuous Integration，持续集成。指代码集成到主干分支。一般会要求在集成前通过自动化测试，只要有一个测试用例失败，就不能集成。目的就是让产品可以快速迭代，同时还能保持高质量。
>CD，Continuous Delivery，持续交付。指的是任何的修改都经过验证，交付成熟的制品，可以随时用于部署到生产环境。
>CD，Continuous Deployment，持续部署。是持续交付的更高阶段，指的是任何修改后的内容都经过验证，自动化的部署到生产环境。
>CD 有两种理解，两者的区别，在于是否自动部署到生产环境。持续交付，只是交付了一个成熟的制品，需要用户手动点击“部署”按钮才能部署到生产环境。

## 自动工作流的工具

流程越复杂，就越有可能出现问题，所以现代开发流程中，都会使用自动化工具来完成每一个阶段的任务。根据每一个阶段所要处理的任务类型，都能找到一个特定类型的工具来处理。

针对开发阶段（初始化、开发）最后会产生的三类代码：
1. 模板代码，即项目模板套用的代码
2. 依赖代码，即依赖的第三方代码
3. 预处理代码，即实际编写的业务代码

这三类代码，对应着开发阶段的三类工具：
1. 模板代码 -----> **脚手架工具**，也可以叫`CLI（command-line interface）`工具: `commander / chalk / inquirer / cosmiconfig`。
2. 依赖代码 -----> **依赖管理工具**：`bower / npm / yarn`，bower 基本已经落伍，`npm` 一统前后端。
3. 预处理代码 -----> **构建工具**：`npmRunScript / browserify / grunt / gulp / webpack / rollup / parcel / snowpack / lerna / roman `等。
   1. 代码质量，即各种代码规范：
      1. 代码规范校验工具：`htmllint / stylelint / eslint + Prettier / editorconfig`
      2. git-commit 规范：`commitlint + commitizen + cz-conventional-changelog`
      3. pre-commit 工具：`husky + lint-staged `
   2. 代码测试： 单元测试 `Jest`、端到端测试 `cypress`
   3. 代码编译：
      1. HTML 模板：`ejs / pug`
      2. CSS 预处理器：`scss / less / stylus / postcss`
      3. ES 编译： `babel`
      4. TS 编译： `typescript`
   4. 代码优化、代码分割、tree-shaking、source-map、模块打包、热更新**HMR**等功能现在基本都为打包器自带功能，如`webpack / rollup / parcel`。
      1. 打包器因为插件化的优势更加全能，基本替代了工作流构建工具 `grunt / gulp`。
      2. `lerna` 是一款用于管理包含多个软件包（package）的 JavaScript 项目，如 UI 库、JS工具库等。
      3. `roman`是一款还在开发中的工具，致力于打造一个完整的 JS 开发工具链，集代码检测、打包、编译、测试等功能于一身。
4. 整体工作流工具：`npmRunScript / grunt / gulp`。
   
   [从Npm Script到Webpack，6种常见的前端构建工具对比](https://zhuanlan.zhihu.com/p/148701657)
   
   > 上面例举的工具有些过时了，有些新兴的，具体任务需求对应工具可各行搜索，此处只是说明举例。

