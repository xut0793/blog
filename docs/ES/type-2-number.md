# Number 类型

[[toc]]

结论：在ES中，Number数值类型遵循IEE-754国际标准，采用64位双精度浮点数来表示。

对JS数值的学习总结，主要需要理解以下几个问题：

- 在JS中是如何表示整数和小数的
- 什么是浮点数
- JS中整数和小数的存储都有范围限制，超出安全范围都会丢失精度
- JS中数值计算精度丢失是怎么回事
- 数据类型中类型标识二进制编码001代表整形数值又是应用哪些地方？

JavaScript 中所有数字都是浮点数，整数是没有小数部分的浮点数，整数和小数统一为一种类型 — Number。

它的实现遵循 IEEE-754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。
> 这点与其它语言如 Java 和 Python 不同，比如JAVA中数值类型有byte/short/int/long/float/double

只用一种数值类型的存储结构的优点是可以**归一化处理整数和小数，节省存储空间**。
> 毕竟当初创造JS时的定位只是浏览器脚本，并没有预见到现在JS的大范围使用。

### 浮点数

首先我们需要知道：什么是浮点数？[为什么叫浮点数?](https://www.zhihu.com/question/19848808)

浮点数是相对于定点数来说的，都是小数在计算机内存中的存储方式。简单理解：用浮点数来表示小数，小数点位置是浮动不确定的，具体是根据浮点数的指数位来决定的。

以十进制数举例：

314.15968 = 31.415968 × 10<sup>1</sup> = 3.1415968 × 10<sup>2</sup> = 31415.968 × 10<sup>-2</sup>


采用浮点数在计算机内存中储存数据，存储的内存空间分为三部分表示：（以64位浮点数标准）（从右向左）

符号位S | 指数位E | 小数位F
--|--|--
占1位 | 占11位 | 占52位
第 63 位| 第62-52位 | 第51 - 0位
正负数符号位（sign）<br>0代表正数，1代表负数 | 存储指数（exponent）<br>用来表示2的几次方数 | 小数位（fraction）<br>超出的部分自动进一舍零

浮点数存储默认整数为一位且为1，即小数点前为1，所以这一位不用写到内存中，节约内存空间。

根据上面的约定，一个数字的值可以根据下面的公司算出：

(-1)<sup>sign</sup> × 1.fraction × 2<sup>exponent</sup>

特别要注意的是指数exponent，是一个无符号整数，在内存分配中占11位，这样能表示的数值范围是0-2047（2<sup>11</sup>-1）。理论上讲，当指数exponent为正时，上述公式计算出来的数值为正负整数，当指数exponent为负时，上述公式计算出来的就是小数了。这就是上面所说JS中用浮点数来表示数值的原因，可以用一种模型归一化表示整数和小数。

但因为指数exponent在划分的内存中是一个无符号整数，所以需要一个中间值，当小于这个中间值为负，表示小数，大于这个中间值为正，表示整数。而2047的中间值刚好是1023。因此指数也被分为四种情况：0，1-1022为负，1023-2046为正，2047。

其中各个分段规则约定为：
- 指数位全为0（0）：即参与计算的exponent=-1023，这时整数位就不再默认为1了，
  - 当整数位为0时，小数位fraction为也同时为0，那根据符号位就可以表示±0，
  - 当整数位为1时，小数位fraction的未尾位（第0位）为1，可以表示一个最接近于1的小数。
- 指数位全为1（2047）：即参与计算的exponent=1024时，
  - 如果小数位fraction全为0，表示±无穷大（正负取决于符号位s）；
  - 如果小数位fraction不全为0，表示这个数不是一个数（NaN）。
- 指数位位于（1~2046）。这时，浮点数就采用上面中间值的规则计算，即指数位实际值E的减去中间值1023，得到参与计算的exponent值（exponent = E -1023）。
  - （1-1022），即参与计算的exponent值为（-1022到-1），则为小数
  - （1023-2046），即参与计算的exponent值为（0-1023），则为整数。

![number](./images/number.png)

### Number 常量属性

- 安全整数`Number.MAX_SAFE_INTEGER` / `MIN_SAFE_INTEGER`

从上面约定的规则最后一点，要表示整数，指数位可以位于（1023-2046），即参与计算的exponent值为（0-1023），但实际上因为小数位fraction最多能到52位，所以参与计算的exponent值为52时最安全，加上小数点前面默认的整数位1，则JS能够表示的安全正整数为：

1.1111(重复52个1)×2<sup>52</sup> 等于 2<sup>53</sup>-1

这个数字用十进制表示是`9007199254740991`（大约900万亿，即约为9*10<sup>15</sup>），所以JS中的最大安全整数：`Number.MAX_SAFE_INTEGER=9007199254740991`。

同理，若符号位sign为1，表示负数，`Number.MIN_SAFE_INTEGER=-9007199254740991`。

在这个范围内的整数都可以精确地表示，对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的精度，因为存储超出内存空间会被舍去，就这就整数精度丢失的问题。（0舍1入，类似十进制数的四舍五入）

- 最大数 `Number.MAX_VALUE`

当指数位除去最大值2047（全为1时约定有特殊意义，表示正负无穷大和NaN), 能到达约定的最大值2046，此时参与计算的exponent=1023，然后小数位fraction全为1时，就是最大数`Number.MAX_VALUE`，即1.111（重复52个）×2<sup>1023</sup>
![max_value.png](./images/max_value.png)

- 最小数数 `Number.MIN_VALUE`

当默认整数位为0，且小数位fraction最后一位为1，指数位除去约定的0，能到达约定的最小值1，此时参与计算的exponent=-1022，就是最小负数`Number.MIN_VALUE`，即0.000（重复51个0）1 × 2<sup>-1022</sup>，十进制数表示5 × 10<sup>-324</sup>
![min_value.png](./images/min_value.png)
```js
Number.MAX_VALUE; // 1.7976931348623157e+308
Number.MIN_VALUE; // 5e-324
```
- 最接近1的浮点数与1的差值 `Number.EPSILON`，就是上面约定规则第一条第二点。
![epsilon.png](./images/epsilon.png)

### 浮点数精度丢失问题

最常见的`0.1 + 0.2 != 0.3`来解释下原因：

在小数表示上，二进制的指数基是2，即2<sup>-xxx</sup>表示小数，所以分母是2的倍数时可以完整表示，比如 1/2，3/4=3/2<sup>2</sup>，1/8=1/2<sup>3</sup>，但如果是1/10 = 1/(2×5)，或者2/10=1/5，1/3这类分母不是2的倍数时，就会像十进制小数中1/3、1/6这样会出现无限循环的小数位。同理，1/10和1/5用二进制来表示也会出现无限循环的位数。此时当位数超出小数位fraction所能表达的最大52位时，会采用类似十进制中的四舍五入，在二进制中用舍0进1的规则。就是JS中小数计算精度丢失的原因。
> 不管是整数还是小数精度丢失，根本原因是数的存储是有位数限制的，超出就会被截断导致精度丢失。

```js
// 十进制的 0.1 转化为二进制，会得到如下结果：
0.0001 1001 1001 1001 1001 1001 1001 1001 …（1001无限循环）
// 而存储结构中的小数部分最多只能表示 52 位。为了能表示 0.1，只能模仿十进制进行四舍五入了，但二进制只有 0 和 1 ， 于是变为 0 舍 1 入 。 因此，0.1 在计算机里的二进制表示形式如下：
0.0001100110011001100110011001100110011001100110011001101
// 转换成上面公式的格式，即整数位保持1（下标2代表二进制），即小数点右移4位，即指数为-4
(−1)0 × 2−4 × (1.1001100110011001100110011001100110011001100110011010)2

// 同样，0.2 也会舍去，二进制也可以表示为： 
(−1)0 × 2−3 × (1.1001100110011001100110011001100110011001100110011010)2 

// 在计算浮点数相加时，需要先进行 “对位”，将较小的指数化为较大的指数，即保持指数位一致，并将小数部分相应右移：
0.1=> (−1)0 × 2−3 × (0.11001100110011001100110011001100110011001100110011010)2
0.2=> (−1)0 × 2−3 × (1.1001100110011001100110011001100110011001100110011010)2
```
最终，“0.1 + 0.2” 在计算机里的计算过程如下：
![calc.png](./images/calc.png)

```js
// 经过上面的计算过程，0.1 + 0.2 得到的结果也可以表示为：
(−1)0 × 2−2 × (1.0011001100110011001100110011001100110011001100110100)2

// 将这个二进制结果转化为十进制表示：
0.30000000000000004
```
这是一个典型的精度丢失案例，从上面的计算过程可以看出，0.1 和 0.2 在转换为二进制时就发生了一次精度丢失，而对于计算后的二进制又有一次精度丢失 。因此，得到的结果是不准确的。

### 精度丢失的解决办法

关于 js 浮点数运算精度丢失的问题，不同场景可以有不同的解决方案。

-如果只是用来展示一个浮点数的结果（即保留几位小数），则可以借用 Number 对象的 toFixed 和 parseFloat 方法。下面代码片段中，fixed 参数表示要保留几位小数，可以根据实际场景调整精度。
```js
function formatNum(num, fixed = 10) { 
  return parseFloat(a.toFixed(fixed))
}
var a = 0.1 + 0.2;
console.log(formatNum(a)); //0.3
```
- 如果需要进行浮点数的加减乘除等运算，由上文可知，在小于 Number.MAXSAFEINTEGER 范围的整数是可以被精确表示出来的，所以可以先把小数转化为整数，运算得到结果后再转化为对应的小数。比如两个浮点数的加法：
```js
function add(num1, num2) { 
  var decimalLen1 = (num1.toString().split('.')[1] || '').length; //第一个参数的小数个数
  var decimalLen2 = (num2.toString().split('.')[1] || '').length; //第二个参数的小数个数  
  var baseNum = Math.pow(10, Math.max(decimalLen1, decimalLen2));  
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
console.log(add(0.1 , 0.2)); //0.3
```
- 采用第三方库，如numbers.js


### 参考链接
- [抓住数据的小尾巴 - JS浮点数陷阱及解法](https://zhuanlan.zhihu.com/p/30703042)
- [binaryconvert图形化验证](http://www.binaryconvert.com/result_signed_int.html?decimal=049050051051052052052)
- [细说 JavaScript 七种数据类型](https://www.cnblogs.com/onepixel/p/5140944.html)
- [JS中如何理解浮点数？](https://www.cnblogs.com/qcloud1001/p/10178391.html)

